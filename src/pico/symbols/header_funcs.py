#!/usr/bin/python3
#
# Obtain lists of function names from header files
#
import sys
import os

# Functions which are dependent on non-default #defines
exclude_funcs = ['vfctprintf', 'queue_get_max_level', 'queue_reset_max_level']

def header_funcs (sIn, fOut, fStub):
    sHeader = sIn[sIn.find ('/include/') + 9:]
    bStub = False
    with open (sIn, 'r') as fIn:
        bInCmnt = False
        bInMacro = False
        bDebug = False
        nBrace = 0
        nIf = 0
        sPrefix = ''
        for sLine in fIn:
            sLine = sPrefix + sLine.strip ()
            sPrefix = ''
            if ( bInCmnt ):
                if ( sLine.endswith ('*/') ):
                    bInCmnt = False
            elif ( bInMacro ):
                if ( not sLine.endswith ('\\') ):
                    bInMacro = False
            elif ( sLine.startswith ('/*') ):
                bInCmnt = True
            elif ( sLine.startswith ('//') ):
                pass
            elif ( sLine.startswith ('#') ):
                if ( sLine.endswith ('\\') ):
                    bInMacro = True
                if ( bDebug ):
                    if ( sLine.startswith ('#if') ):
                        nIf += 1
                    elif ( sLine == '#endif' ):
                        nIf -= 1
                        if ( nIf == 0 ):
                            bDebug = False
                elif ( sLine == '#ifndef NDEBUG' ):
                    bDebug = True
                    nIf = 1
            else:
                nBrace += sLine.count ('{')
                if ( sLine == 'extern "C" {' ):
                    nBrace -= 1
                if ( not bDebug ):
                    nCh = sLine.find ('(')
                    if ( nCh > 0 ):
                        lTerms = sLine[0:nCh].split ()
                        if (( len (lTerms) > 1 )
                            and ( not lTerms[-1].startswith ('__') )
                            and ( not lTerms[-1].startswith ('weak') )
                            and ( not lTerms[-1].endswith ('_unsafe') )
                            and ( not lTerms[-1] in exclude_funcs )):
                            sPtr = ''
                            if ( lTerms[-1][0] == '*' ):
                                lTerms[-1] = lTerms[-1][1:]
                                sPtr = '*'
                            if (( nBrace == 0 ) and ( lTerms[0] not in ['static', 'typedef'] )):
                                fOut.write (lTerms[-1] + '\n')
                            elif (( lTerms[0] == 'static' ) and ( len (lTerms) > 3 )):
                                nCh2 = sLine.find (')')
                                if ( nCh2 > 0 ):
                                    if ( not bStub ):
                                        fStub.write ('\n#include "' + sHeader + '"\n')
                                        bStub = True
                                    lParm = sLine[nCh+1:nCh2].split (',')
                                    fStub.write ('\n' + (' '.join (lTerms[2:-1])) + ' ')
                                    fStub.write (sPtr + 'stub_' + lTerms[-1] + ' ')
                                    fStub.write (sLine[nCh:nCh2+1] + '\n    {\n    ')
                                    if ( lTerms[2] != 'void' ):
                                        fStub.write ('return ')
                                    fStub.write (lTerms[-1])
                                    for i in range (len (lParm)):
                                        lParm[i] = lParm[i].strip ().split ()[-1].replace ('*', '')
                                        if ( lParm[i] == 'void' ):
                                            lParm[i] = ''
                                    fStub.write (' (' + (', '.join (lParm)) + ');\n    }\n')
                                    fOut.write (lTerms[-1] + '\tstub_' + lTerms[-1] + '\n')
                                else:
                                    sPrefix = sLine + ' '
                nBrace -= sLine.count ('}')
                if ( nBrace < 0 ):
                    nBrace = 0

def header_list (sList, sOut, sStub):
    sSDK = os.getenv ('PICO_SDK_PATH', '../../../../pico-sdk')
    with open (sList, 'r') as fList, open (sOut, 'w') as fOut, open (sStub, 'w') as fStub:
        fOut.write ('# ' + sOut + ' - SDK routines for inclusion in BBC BASIC SYM table\n'
                     '# Automatically generated by header_funcs.py ' + sList + ' '
                     + sOut + ' ' + sStub + '\n# Do not edit\n#\n')
        fStub.write ('// ' + sStub + ' - Stub functions for SDK routines that are otherwise inline\n'
                     '// Automatically generated by header_funcs.py ' + sList + ' '
                     + sOut + ' ' + sStub + '\n// Do not edit\n\n')
        for sLine in fList:
            sLine = sLine.strip ()
            if (( len (sLine) > 0 ) and ( sLine[0] != '#' )):
                sHeader = os.path.join (sSDK, sLine)
                header_funcs (sHeader, fOut, fStub)

if ( len (sys.argv) == 4 ):
    header_list (sys.argv[1], sys.argv[2], sys.argv[3])
else:
    print ('Usage: header_funcs.py <headers file> <symbol file> <stubs file>')
    sys.exit (1)
