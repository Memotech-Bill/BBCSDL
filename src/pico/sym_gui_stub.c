// sym_gui_stub.c - Stub functions for SDK routines that are otherwise inline
// Automatically generated by header_funcs.py symbols/sym_gui_sdk.txt sym_gui_stub.c ../../src/pico/symbols/sdk_headers.txt
// Do not edit


#include "pico/types.h"

uint64_t stub_to_us_since_boot (absolute_time_t t)
    {
    return to_us_since_boot (t);
    }

void stub_update_us_since_boot (absolute_time_t *t, uint64_t us_since_boot)
    {
    update_us_since_boot (t, us_since_boot);
    }

#include "pico/divider.h"

int32_t stub_divmod_s32s32_rem (int32_t a, int32_t b, int32_t *rem)
    {
    return divmod_s32s32_rem (a, b, rem);
    }

uint32_t stub_divmod_u32u32_rem (uint32_t a, uint32_t b, uint32_t *rem)
    {
    return divmod_u32u32_rem (a, b, rem);
    }

#include "pico/stdlib.h"

bool stub_set_sys_clock_khz (uint32_t freq_khz, bool required)
    {
    return set_sys_clock_khz (freq_khz, required);
    }

#include "pico/critical_section.h"

void stub_critical_section_enter_blocking (critical_section_t *crit_sec)
    {
    critical_section_enter_blocking (crit_sec);
    }

void stub_critical_section_exit (critical_section_t *crit_sec)
    {
    critical_section_exit (crit_sec);
    }

#include "pico/mutex.h"

bool stub_mutex_is_initialized (mutex_t *mtx)
    {
    return mutex_is_initialized (mtx);
    }

bool stub_recursive_mutex_is_initialized (recursive_mutex_t *mtx)
    {
    return recursive_mutex_is_initialized (mtx);
    }

#include "pico/time.h"

absolute_time_t stub_get_absolute_time (void)
    {
    return get_absolute_time ();
    }

uint32_t stub_us_to_ms (uint64_t us)
    {
    return us_to_ms (us);
    }

uint32_t stub_to_ms_since_boot (absolute_time_t t)
    {
    return to_ms_since_boot (t);
    }

absolute_time_t stub_delayed_by_us (const absolute_time_t t, uint64_t us)
    {
    return delayed_by_us (t, us);
    }

absolute_time_t stub_delayed_by_ms (const absolute_time_t t, uint32_t ms)
    {
    return delayed_by_ms (t, ms);
    }

absolute_time_t stub_make_timeout_time_us (uint64_t us)
    {
    return make_timeout_time_us (us);
    }

absolute_time_t stub_make_timeout_time_ms (uint32_t ms)
    {
    return make_timeout_time_ms (ms);
    }

int64_t stub_absolute_time_diff_us (absolute_time_t from, absolute_time_t to)
    {
    return absolute_time_diff_us (from, to);
    }

bool stub_is_at_the_end_of_time (absolute_time_t t)
    {
    return is_at_the_end_of_time (t);
    }

bool stub_is_nil_time (absolute_time_t t)
    {
    return is_nil_time (t);
    }

alarm_id_t stub_alarm_pool_add_alarm_in_us (alarm_pool_t *pool, uint64_t us, alarm_callback_t callback, void *user_data, bool fire_if_past)
    {
    return alarm_pool_add_alarm_in_us (pool, us, callback, user_data, fire_if_past);
    }

alarm_id_t stub_alarm_pool_add_alarm_in_ms (alarm_pool_t *pool, uint32_t ms, alarm_callback_t callback, void *user_data, bool fire_if_past)
    {
    return alarm_pool_add_alarm_in_ms (pool, ms, callback, user_data, fire_if_past);
    }

alarm_id_t stub_add_alarm_at (absolute_time_t time, alarm_callback_t callback, void *user_data, bool fire_if_past)
    {
    return add_alarm_at (time, callback, user_data, fire_if_past);
    }

alarm_id_t stub_add_alarm_in_us (uint64_t us, alarm_callback_t callback, void *user_data, bool fire_if_past)
    {
    return add_alarm_in_us (us, callback, user_data, fire_if_past);
    }

alarm_id_t stub_add_alarm_in_ms (uint32_t ms, alarm_callback_t callback, void *user_data, bool fire_if_past)
    {
    return add_alarm_in_ms (ms, callback, user_data, fire_if_past);
    }

bool stub_cancel_alarm (alarm_id_t alarm_id)
    {
    return cancel_alarm (alarm_id);
    }

bool stub_alarm_pool_add_repeating_timer_ms (alarm_pool_t *pool, int32_t delay_ms, repeating_timer_callback_t callback, void *user_data, repeating_timer_t *out)
    {
    return alarm_pool_add_repeating_timer_ms (pool, delay_ms, callback, user_data, out);
    }

bool stub_add_repeating_timer_us (int64_t delay_us, repeating_timer_callback_t callback, void *user_data, repeating_timer_t *out)
    {
    return add_repeating_timer_us (delay_us, callback, user_data, out);
    }

bool stub_add_repeating_timer_ms (int32_t delay_ms, repeating_timer_callback_t callback, void *user_data, repeating_timer_t *out)
    {
    return add_repeating_timer_ms (delay_ms, callback, user_data, out);
    }

#include "pico/util/pheap.h"

pheap_node_t *stub_ph_get_node (pheap_t *heap, pheap_node_id_t id)
    {
    return ph_get_node (heap, id);
    }

pheap_node_id_t stub_ph_new_node (pheap_t *heap)
    {
    return ph_new_node (heap);
    }

pheap_node_id_t stub_ph_insert_node (pheap_t *heap, pheap_node_id_t id)
    {
    return ph_insert_node (heap, id);
    }

pheap_node_id_t stub_ph_peek_head (pheap_t *heap)
    {
    return ph_peek_head (heap);
    }

pheap_node_id_t stub_ph_remove_and_free_head (pheap_t *heap)
    {
    return ph_remove_and_free_head (heap);
    }

bool stub_ph_contains_node (pheap_t *heap, pheap_node_id_t id)
    {
    return ph_contains_node (heap, id);
    }

void stub_ph_free_node (pheap_t *heap, pheap_node_id_t id)
    {
    ph_free_node (heap, id);
    }

#include "pico/util/queue.h"

void stub_queue_init (queue_t *q, uint element_size, uint element_count)
    {
    queue_init (q, element_size, element_count);
    }

uint stub_queue_get_level (queue_t *q)
    {
    return queue_get_level (q);
    }

bool stub_queue_is_empty (queue_t *q)
    {
    return queue_is_empty (q);
    }

bool stub_queue_is_full (queue_t *q)
    {
    return queue_is_full (q);
    }

#include "hardware/adc.h"

void stub_adc_gpio_init (uint gpio)
    {
    adc_gpio_init (gpio);
    }

void stub_adc_select_input (uint input)
    {
    adc_select_input (input);
    }

uint stub_adc_get_selected_input (void)
    {
    return adc_get_selected_input ();
    }

void stub_adc_set_round_robin (uint input_mask)
    {
    adc_set_round_robin (input_mask);
    }

void stub_adc_set_temp_sensor_enabled (bool enable)
    {
    adc_set_temp_sensor_enabled (enable);
    }

uint16_t stub_adc_read (void)
    {
    return adc_read ();
    }

void stub_adc_run (bool run)
    {
    adc_run (run);
    }

void stub_adc_set_clkdiv (float clkdiv)
    {
    adc_set_clkdiv (clkdiv);
    }

void stub_adc_fifo_setup (bool en, bool dreq_en, uint16_t dreq_thresh, bool err_in_fifo, bool byte_shift)
    {
    adc_fifo_setup (en, dreq_en, dreq_thresh, err_in_fifo, byte_shift);
    }

bool stub_adc_fifo_is_empty (void)
    {
    return adc_fifo_is_empty ();
    }

uint8_t stub_adc_fifo_get_level (void)
    {
    return adc_fifo_get_level ();
    }

uint16_t stub_adc_fifo_get (void)
    {
    return adc_fifo_get ();
    }

uint16_t stub_adc_fifo_get_blocking (void)
    {
    return adc_fifo_get_blocking ();
    }

void stub_adc_fifo_drain (void)
    {
    adc_fifo_drain ();
    }

void stub_adc_irq_set_enabled (bool enabled)
    {
    adc_irq_set_enabled (enabled);
    }

#include "hardware/address_mapped.h"

uint32_t stub_xip_alias_check_addr (const void *addr)
    {
    return xip_alias_check_addr (addr);
    }

#include "hardware/clocks.h"

float stub_frequency_count_mhz (uint src)
    {
    return frequency_count_mhz (src);
    }

#include "hardware/divider.h"

void stub_hw_divider_divmod_s32_start (int32_t a, int32_t b)
    {
    hw_divider_divmod_s32_start (a, b);
    }

void stub_hw_divider_divmod_u32_start (uint32_t a, uint32_t b)
    {
    hw_divider_divmod_u32_start (a, b);
    }

void stub_hw_divider_wait_ready (void)
    {
    hw_divider_wait_ready ();
    }

divmod_result_t stub_hw_divider_result_nowait (void)
    {
    return hw_divider_result_nowait ();
    }

divmod_result_t stub_hw_divider_result_wait (void)
    {
    return hw_divider_result_wait ();
    }

uint32_t stub_hw_divider_u32_quotient_wait (void)
    {
    return hw_divider_u32_quotient_wait ();
    }

int32_t stub_hw_divider_s32_quotient_wait (void)
    {
    return hw_divider_s32_quotient_wait ();
    }

uint32_t stub_hw_divider_u32_remainder_wait (void)
    {
    return hw_divider_u32_remainder_wait ();
    }

int32_t stub_hw_divider_s32_remainder_wait (void)
    {
    return hw_divider_s32_remainder_wait ();
    }

uint32_t stub_hw_divider_u32_quotient (uint32_t a, uint32_t b)
    {
    return hw_divider_u32_quotient (a, b);
    }

uint32_t stub_hw_divider_u32_remainder (uint32_t a, uint32_t b)
    {
    return hw_divider_u32_remainder (a, b);
    }

int32_t stub_hw_divider_quotient_s32 (int32_t a, int32_t b)
    {
    return hw_divider_quotient_s32 (a, b);
    }

int32_t stub_hw_divider_remainder_s32 (int32_t a, int32_t b)
    {
    return hw_divider_remainder_s32 (a, b);
    }

void stub_hw_divider_pause (void)
    {
    hw_divider_pause ();
    }

uint32_t stub_hw_divider_u32_quotient_inlined (uint32_t a, uint32_t b)
    {
    return hw_divider_u32_quotient_inlined (a, b);
    }

uint32_t stub_hw_divider_u32_remainder_inlined (uint32_t a, uint32_t b)
    {
    return hw_divider_u32_remainder_inlined (a, b);
    }

int32_t stub_hw_divider_s32_quotient_inlined (int32_t a, int32_t b)
    {
    return hw_divider_s32_quotient_inlined (a, b);
    }

int32_t stub_hw_divider_s32_remainder_inlined (int32_t a, int32_t b)
    {
    return hw_divider_s32_remainder_inlined (a, b);
    }

#include "hardware/dma.h"

void stub_check_dma_channel_param (__unused uint channel)
    {
    check_dma_channel_param (channel);
    }

void stub_check_dma_timer_param (__unused uint timer_num)
    {
    check_dma_timer_param (timer_num);
    }

void stub_channel_config_set_read_increment (dma_channel_config *c, bool incr)
    {
    channel_config_set_read_increment (c, incr);
    }

void stub_channel_config_set_write_increment (dma_channel_config *c, bool incr)
    {
    channel_config_set_write_increment (c, incr);
    }

void stub_channel_config_set_dreq (dma_channel_config *c, uint dreq)
    {
    channel_config_set_dreq (c, dreq);
    }

void stub_channel_config_set_chain_to (dma_channel_config *c, uint chain_to)
    {
    channel_config_set_chain_to (c, chain_to);
    }

void stub_channel_config_set_transfer_data_size (dma_channel_config *c, enum dma_channel_transfer_size size)
    {
    channel_config_set_transfer_data_size (c, size);
    }

void stub_channel_config_set_ring (dma_channel_config *c, bool write, uint size_bits)
    {
    channel_config_set_ring (c, write, size_bits);
    }

void stub_channel_config_set_bswap (dma_channel_config *c, bool bswap)
    {
    channel_config_set_bswap (c, bswap);
    }

void stub_channel_config_set_irq_quiet (dma_channel_config *c, bool irq_quiet)
    {
    channel_config_set_irq_quiet (c, irq_quiet);
    }

void stub_channel_config_set_high_priority (dma_channel_config *c, bool high_priority)
    {
    channel_config_set_high_priority (c, high_priority);
    }

void stub_channel_config_set_enable (dma_channel_config *c, bool enable)
    {
    channel_config_set_enable (c, enable);
    }

void stub_channel_config_set_sniff_enable (dma_channel_config *c, bool sniff_enable)
    {
    channel_config_set_sniff_enable (c, sniff_enable);
    }

dma_channel_config stub_dma_channel_get_default_config (uint channel)
    {
    return dma_channel_get_default_config (channel);
    }

dma_channel_config stub_dma_get_channel_config (uint channel)
    {
    return dma_get_channel_config (channel);
    }

uint32_t stub_channel_config_get_ctrl_value (const dma_channel_config *config)
    {
    return channel_config_get_ctrl_value (config);
    }

void stub_dma_channel_set_config (uint channel, const dma_channel_config *config, bool trigger)
    {
    dma_channel_set_config (channel, config, trigger);
    }

void stub_dma_channel_set_read_addr (uint channel, const volatile void *read_addr, bool trigger)
    {
    dma_channel_set_read_addr (channel, read_addr, trigger);
    }

void stub_dma_channel_set_write_addr (uint channel, volatile void *write_addr, bool trigger)
    {
    dma_channel_set_write_addr (channel, write_addr, trigger);
    }

void stub_dma_channel_set_trans_count (uint channel, uint32_t trans_count, bool trigger)
    {
    dma_channel_set_trans_count (channel, trans_count, trigger);
    }

void stub_dma_channel_configure (uint channel, const dma_channel_config *config, volatile void *write_addr, const volatile void *read_addr, uint transfer_count, bool trigger)
    {
    dma_channel_configure (channel, config, write_addr, read_addr, transfer_count, trigger);
    }

void stub_dma_start_channel_mask (uint32_t chan_mask)
    {
    dma_start_channel_mask (chan_mask);
    }

void stub_dma_channel_start (uint channel)
    {
    dma_channel_start (channel);
    }

void stub_dma_channel_abort (uint channel)
    {
    dma_channel_abort (channel);
    }

void stub_dma_channel_set_irq0_enabled (uint channel, bool enabled)
    {
    dma_channel_set_irq0_enabled (channel, enabled);
    }

void stub_dma_set_irq0_channel_mask_enabled (uint32_t channel_mask, bool enabled)
    {
    dma_set_irq0_channel_mask_enabled (channel_mask, enabled);
    }

void stub_dma_channel_set_irq1_enabled (uint channel, bool enabled)
    {
    dma_channel_set_irq1_enabled (channel, enabled);
    }

void stub_dma_set_irq1_channel_mask_enabled (uint32_t channel_mask, bool enabled)
    {
    dma_set_irq1_channel_mask_enabled (channel_mask, enabled);
    }

void stub_dma_irqn_set_channel_enabled (uint irq_index, uint channel, bool enabled)
    {
    dma_irqn_set_channel_enabled (irq_index, channel, enabled);
    }

void stub_dma_irqn_set_channel_mask_enabled (uint irq_index, uint32_t channel_mask,  bool enabled)
    {
    dma_irqn_set_channel_mask_enabled (irq_index, channel_mask, enabled);
    }

bool stub_dma_channel_get_irq0_status (uint channel)
    {
    return dma_channel_get_irq0_status (channel);
    }

bool stub_dma_channel_get_irq1_status (uint channel)
    {
    return dma_channel_get_irq1_status (channel);
    }

bool stub_dma_irqn_get_channel_status (uint irq_index, uint channel)
    {
    return dma_irqn_get_channel_status (irq_index, channel);
    }

void stub_dma_channel_acknowledge_irq0 (uint channel)
    {
    dma_channel_acknowledge_irq0 (channel);
    }

void stub_dma_channel_acknowledge_irq1 (uint channel)
    {
    dma_channel_acknowledge_irq1 (channel);
    }

void stub_dma_irqn_acknowledge_channel (uint irq_index, uint channel)
    {
    dma_irqn_acknowledge_channel (irq_index, channel);
    }

void stub_dma_timer_set_fraction (uint timer, uint16_t numerator, uint16_t denominator)
    {
    dma_timer_set_fraction (timer, numerator, denominator);
    }

uint stub_dma_get_timer_dreq (uint timer_num)
    {
    return dma_get_timer_dreq (timer_num);
    }

#include "hardware/gpio.h"

void stub_check_gpio_param (__unused uint gpio)
    {
    check_gpio_param (gpio);
    }

void stub_gpio_pull_up (uint gpio)
    {
    gpio_pull_up (gpio);
    }

bool stub_gpio_is_pulled_up (uint gpio)
    {
    return gpio_is_pulled_up (gpio);
    }

void stub_gpio_pull_down (uint gpio)
    {
    gpio_pull_down (gpio);
    }

bool stub_gpio_is_pulled_down (uint gpio)
    {
    return gpio_is_pulled_down (gpio);
    }

void stub_gpio_disable_pulls (uint gpio)
    {
    gpio_disable_pulls (gpio);
    }

uint32_t stub_gpio_get_irq_event_mask (uint gpio)
    {
    return gpio_get_irq_event_mask (gpio);
    }

void stub_gpio_add_raw_irq_handler_with_order_priority (uint gpio, irq_handler_t handler, uint8_t order_priority)
    {
    gpio_add_raw_irq_handler_with_order_priority (gpio, handler, order_priority);
    }

void stub_gpio_add_raw_irq_handler (uint gpio, irq_handler_t handler)
    {
    gpio_add_raw_irq_handler (gpio, handler);
    }

void stub_gpio_remove_raw_irq_handler (uint gpio, irq_handler_t handler)
    {
    gpio_remove_raw_irq_handler (gpio, handler);
    }

bool stub_gpio_get (uint gpio)
    {
    return gpio_get (gpio);
    }

uint32_t stub_gpio_get_all (void)
    {
    return gpio_get_all ();
    }

void stub_gpio_set_mask (uint32_t mask)
    {
    gpio_set_mask (mask);
    }

void stub_gpio_clr_mask (uint32_t mask)
    {
    gpio_clr_mask (mask);
    }

void stub_gpio_xor_mask (uint32_t mask)
    {
    gpio_xor_mask (mask);
    }

void stub_gpio_put_masked (uint32_t mask, uint32_t value)
    {
    gpio_put_masked (mask, value);
    }

void stub_gpio_put_all (uint32_t value)
    {
    gpio_put_all (value);
    }

void stub_gpio_put (uint gpio, bool value)
    {
    gpio_put (gpio, value);
    }

bool stub_gpio_get_out_level (uint gpio)
    {
    return gpio_get_out_level (gpio);
    }

void stub_gpio_set_dir_out_masked (uint32_t mask)
    {
    gpio_set_dir_out_masked (mask);
    }

void stub_gpio_set_dir_in_masked (uint32_t mask)
    {
    gpio_set_dir_in_masked (mask);
    }

void stub_gpio_set_dir_masked (uint32_t mask, uint32_t value)
    {
    gpio_set_dir_masked (mask, value);
    }

void stub_gpio_set_dir_all_bits (uint32_t values)
    {
    gpio_set_dir_all_bits (values);
    }

void stub_gpio_set_dir (uint gpio, bool out)
    {
    gpio_set_dir (gpio, out);
    }

bool stub_gpio_is_dir_out (uint gpio)
    {
    return gpio_is_dir_out (gpio);
    }

uint stub_gpio_get_dir (uint gpio)
    {
    return gpio_get_dir (gpio);
    }

#include "hardware/i2c.h"

uint stub_i2c_hw_index (i2c_inst_t *i2c)
    {
    return i2c_hw_index (i2c);
    }

i2c_hw_t *stub_i2c_get_hw (i2c_inst_t *i2c)
    {
    return i2c_get_hw (i2c);
    }

int stub_i2c_write_timeout_us (i2c_inst_t *i2c, uint8_t addr, const uint8_t *src, size_t len, bool nostop, uint timeout_us)
    {
    return i2c_write_timeout_us (i2c, addr, src, len, nostop, timeout_us);
    }

int stub_i2c_read_timeout_us (i2c_inst_t *i2c, uint8_t addr, uint8_t *dst, size_t len, bool nostop, uint timeout_us)
    {
    return i2c_read_timeout_us (i2c, addr, dst, len, nostop, timeout_us);
    }

size_t stub_i2c_get_write_available (i2c_inst_t *i2c)
    {
    return i2c_get_write_available (i2c);
    }

size_t stub_i2c_get_read_available (i2c_inst_t *i2c)
    {
    return i2c_get_read_available (i2c);
    }

void stub_i2c_write_raw_blocking (i2c_inst_t *i2c, const uint8_t *src, size_t len)
    {
    i2c_write_raw_blocking (i2c, src, len);
    }

void stub_i2c_read_raw_blocking (i2c_inst_t *i2c, uint8_t *dst, size_t len)
    {
    i2c_read_raw_blocking (i2c, dst, len);
    }

uint stub_i2c_get_dreq (i2c_inst_t *i2c, bool is_tx)
    {
    return i2c_get_dreq (i2c, is_tx);
    }

#include "hardware/interp.h"

uint stub_interp_index (interp_hw_t *interp)
    {
    return interp_index (interp);
    }

void stub_interp_config_set_shift (interp_config *c, uint shift)
    {
    interp_config_set_shift (c, shift);
    }

void stub_interp_config_set_mask (interp_config *c, uint mask_lsb, uint mask_msb)
    {
    interp_config_set_mask (c, mask_lsb, mask_msb);
    }

void stub_interp_config_set_cross_input (interp_config *c, bool cross_input)
    {
    interp_config_set_cross_input (c, cross_input);
    }

void stub_interp_config_set_cross_result (interp_config *c, bool cross_result)
    {
    interp_config_set_cross_result (c, cross_result);
    }

void stub_interp_config_set_signed (interp_config *c, bool _signed)
    {
    interp_config_set_signed (c, _signed);
    }

void stub_interp_config_set_add_raw (interp_config *c, bool add_raw)
    {
    interp_config_set_add_raw (c, add_raw);
    }

void stub_interp_config_set_blend (interp_config *c, bool blend)
    {
    interp_config_set_blend (c, blend);
    }

void stub_interp_config_set_clamp (interp_config *c, bool clamp)
    {
    interp_config_set_clamp (c, clamp);
    }

void stub_interp_config_set_force_bits (interp_config *c, uint bits)
    {
    interp_config_set_force_bits (c, bits);
    }

interp_config stub_interp_default_config (void)
    {
    return interp_default_config ();
    }

void stub_interp_set_config (interp_hw_t *interp, uint lane, interp_config *config)
    {
    interp_set_config (interp, lane, config);
    }

void stub_interp_set_force_bits (interp_hw_t *interp, uint lane, uint bits)
    {
    interp_set_force_bits (interp, lane, bits);
    }

void stub_interp_set_base (interp_hw_t *interp, uint lane, uint32_t val)
    {
    interp_set_base (interp, lane, val);
    }

uint32_t stub_interp_get_base (interp_hw_t *interp, uint lane)
    {
    return interp_get_base (interp, lane);
    }

void stub_interp_set_base_both (interp_hw_t *interp, uint32_t val)
    {
    interp_set_base_both (interp, val);
    }

void stub_interp_set_accumulator (interp_hw_t *interp, uint lane, uint32_t val)
    {
    interp_set_accumulator (interp, lane, val);
    }

uint32_t stub_interp_get_accumulator (interp_hw_t *interp, uint lane)
    {
    return interp_get_accumulator (interp, lane);
    }

uint32_t stub_interp_pop_lane_result (interp_hw_t *interp, uint lane)
    {
    return interp_pop_lane_result (interp, lane);
    }

uint32_t stub_interp_peek_lane_result (interp_hw_t *interp, uint lane)
    {
    return interp_peek_lane_result (interp, lane);
    }

uint32_t stub_interp_pop_full_result (interp_hw_t *interp)
    {
    return interp_pop_full_result (interp);
    }

uint32_t stub_interp_peek_full_result (interp_hw_t *interp)
    {
    return interp_peek_full_result (interp);
    }

void stub_interp_add_accumulater (interp_hw_t *interp, uint lane, uint32_t val)
    {
    interp_add_accumulater (interp, lane, val);
    }

uint32_t stub_interp_get_raw (interp_hw_t *interp, uint lane)
    {
    return interp_get_raw (interp, lane);
    }

#include "hardware/irq.h"

void stub_check_irq_param (__unused uint num)
    {
    check_irq_param (num);
    }

void stub_irq_clear (uint int_num)
    {
    irq_clear (int_num);
    }

#include "hardware/pio.h"

void stub_check_sm_param (__unused uint sm)
    {
    check_sm_param (sm);
    }

void stub_check_sm_mask (__unused uint mask)
    {
    check_sm_mask (mask);
    }

void stub_check_pio_param (__unused PIO pio)
    {
    check_pio_param (pio);
    }

void stub_sm_config_set_out_pins (pio_sm_config *c, uint out_base, uint out_count)
    {
    sm_config_set_out_pins (c, out_base, out_count);
    }

void stub_sm_config_set_set_pins (pio_sm_config *c, uint set_base, uint set_count)
    {
    sm_config_set_set_pins (c, set_base, set_count);
    }

void stub_sm_config_set_in_pins (pio_sm_config *c, uint in_base)
    {
    sm_config_set_in_pins (c, in_base);
    }

void stub_sm_config_set_sideset_pins (pio_sm_config *c, uint sideset_base)
    {
    sm_config_set_sideset_pins (c, sideset_base);
    }

void stub_sm_config_set_sideset (pio_sm_config *c, uint bit_count, bool optional, bool pindirs)
    {
    sm_config_set_sideset (c, bit_count, optional, pindirs);
    }

void stub_sm_config_set_clkdiv_int_frac (pio_sm_config *c, uint16_t div_int, uint8_t div_frac)
    {
    sm_config_set_clkdiv_int_frac (c, div_int, div_frac);
    }

void stub_pio_calculate_clkdiv_from_float (float div, uint16_t *div_int, uint8_t *div_frac)
    {
    pio_calculate_clkdiv_from_float (div, div_int, div_frac);
    }

void stub_sm_config_set_clkdiv (pio_sm_config *c, float div)
    {
    sm_config_set_clkdiv (c, div);
    }

void stub_sm_config_set_wrap (pio_sm_config *c, uint wrap_target, uint wrap)
    {
    sm_config_set_wrap (c, wrap_target, wrap);
    }

void stub_sm_config_set_jmp_pin (pio_sm_config *c, uint pin)
    {
    sm_config_set_jmp_pin (c, pin);
    }

void stub_sm_config_set_in_shift (pio_sm_config *c, bool shift_right, bool autopush, uint push_threshold)
    {
    sm_config_set_in_shift (c, shift_right, autopush, push_threshold);
    }

void stub_sm_config_set_out_shift (pio_sm_config *c, bool shift_right, bool autopull, uint pull_threshold)
    {
    sm_config_set_out_shift (c, shift_right, autopull, pull_threshold);
    }

void stub_sm_config_set_fifo_join (pio_sm_config *c, enum pio_fifo_join join)
    {
    sm_config_set_fifo_join (c, join);
    }

void stub_sm_config_set_out_special (pio_sm_config *c, bool sticky, bool has_enable_pin, uint enable_pin_index)
    {
    sm_config_set_out_special (c, sticky, has_enable_pin, enable_pin_index);
    }

void stub_sm_config_set_mov_status (pio_sm_config *c, enum pio_mov_status_type status_sel, uint status_n)
    {
    sm_config_set_mov_status (c, status_sel, status_n);
    }

pio_sm_config stub_pio_get_default_sm_config (void)
    {
    return pio_get_default_sm_config ();
    }

void stub_pio_sm_set_config (PIO pio, uint sm, const pio_sm_config *config)
    {
    pio_sm_set_config (pio, sm, config);
    }

uint stub_pio_get_index (PIO pio)
    {
    return pio_get_index (pio);
    }

void stub_pio_gpio_init (PIO pio, uint pin)
    {
    pio_gpio_init (pio, pin);
    }

uint stub_pio_get_dreq (PIO pio, uint sm, bool is_tx)
    {
    return pio_get_dreq (pio, sm, is_tx);
    }

void stub_pio_sm_set_enabled (PIO pio, uint sm, bool enabled)
    {
    pio_sm_set_enabled (pio, sm, enabled);
    }

void stub_pio_set_sm_mask_enabled (PIO pio, uint32_t mask, bool enabled)
    {
    pio_set_sm_mask_enabled (pio, mask, enabled);
    }

void stub_pio_sm_restart (PIO pio, uint sm)
    {
    pio_sm_restart (pio, sm);
    }

void stub_pio_restart_sm_mask (PIO pio, uint32_t mask)
    {
    pio_restart_sm_mask (pio, mask);
    }

void stub_pio_sm_clkdiv_restart (PIO pio, uint sm)
    {
    pio_sm_clkdiv_restart (pio, sm);
    }

void stub_pio_clkdiv_restart_sm_mask (PIO pio, uint32_t mask)
    {
    pio_clkdiv_restart_sm_mask (pio, mask);
    }

void stub_pio_enable_sm_mask_in_sync (PIO pio, uint32_t mask)
    {
    pio_enable_sm_mask_in_sync (pio, mask);
    }

void stub_pio_set_irq0_source_enabled (PIO pio, enum pio_interrupt_source source, bool enabled)
    {
    pio_set_irq0_source_enabled (pio, source, enabled);
    }

void stub_pio_set_irq1_source_enabled (PIO pio, enum pio_interrupt_source source, bool enabled)
    {
    pio_set_irq1_source_enabled (pio, source, enabled);
    }

void stub_pio_set_irq0_source_mask_enabled (PIO pio, uint32_t source_mask, bool enabled)
    {
    pio_set_irq0_source_mask_enabled (pio, source_mask, enabled);
    }

void stub_pio_set_irq1_source_mask_enabled (PIO pio, uint32_t source_mask, bool enabled)
    {
    pio_set_irq1_source_mask_enabled (pio, source_mask, enabled);
    }

void stub_pio_set_irqn_source_enabled (PIO pio, uint irq_index, enum pio_interrupt_source source, bool enabled)
    {
    pio_set_irqn_source_enabled (pio, irq_index, source, enabled);
    }

void stub_pio_set_irqn_source_mask_enabled (PIO pio, uint irq_index, uint32_t source_mask, bool enabled)
    {
    pio_set_irqn_source_mask_enabled (pio, irq_index, source_mask, enabled);
    }

bool stub_pio_interrupt_get (PIO pio, uint pio_interrupt_num)
    {
    return pio_interrupt_get (pio, pio_interrupt_num);
    }

void stub_pio_interrupt_clear (PIO pio, uint pio_interrupt_num)
    {
    pio_interrupt_clear (pio, pio_interrupt_num);
    }

uint8_t stub_pio_sm_get_pc (PIO pio, uint sm)
    {
    return pio_sm_get_pc (pio, sm);
    }

bool stub_pio_sm_is_exec_stalled (PIO pio, uint sm)
    {
    return pio_sm_is_exec_stalled (pio, sm);
    }

void stub_pio_sm_exec_wait_blocking (PIO pio, uint sm, uint instr)
    {
    pio_sm_exec_wait_blocking (pio, sm, instr);
    }

void stub_pio_sm_set_wrap (PIO pio, uint sm, uint wrap_target, uint wrap)
    {
    pio_sm_set_wrap (pio, sm, wrap_target, wrap);
    }

void stub_pio_sm_set_out_pins (PIO pio, uint sm, uint out_base, uint out_count)
    {
    pio_sm_set_out_pins (pio, sm, out_base, out_count);
    }

void stub_pio_sm_set_set_pins (PIO pio, uint sm, uint set_base, uint set_count)
    {
    pio_sm_set_set_pins (pio, sm, set_base, set_count);
    }

void stub_pio_sm_set_in_pins (PIO pio, uint sm, uint in_base)
    {
    pio_sm_set_in_pins (pio, sm, in_base);
    }

void stub_pio_sm_set_sideset_pins (PIO pio, uint sm, uint sideset_base)
    {
    pio_sm_set_sideset_pins (pio, sm, sideset_base);
    }

void stub_pio_sm_put (PIO pio, uint sm, uint32_t data)
    {
    pio_sm_put (pio, sm, data);
    }

uint32_t stub_pio_sm_get (PIO pio, uint sm)
    {
    return pio_sm_get (pio, sm);
    }

bool stub_pio_sm_is_rx_fifo_full (PIO pio, uint sm)
    {
    return pio_sm_is_rx_fifo_full (pio, sm);
    }

bool stub_pio_sm_is_rx_fifo_empty (PIO pio, uint sm)
    {
    return pio_sm_is_rx_fifo_empty (pio, sm);
    }

uint stub_pio_sm_get_rx_fifo_level (PIO pio, uint sm)
    {
    return pio_sm_get_rx_fifo_level (pio, sm);
    }

bool stub_pio_sm_is_tx_fifo_full (PIO pio, uint sm)
    {
    return pio_sm_is_tx_fifo_full (pio, sm);
    }

bool stub_pio_sm_is_tx_fifo_empty (PIO pio, uint sm)
    {
    return pio_sm_is_tx_fifo_empty (pio, sm);
    }

uint stub_pio_sm_get_tx_fifo_level (PIO pio, uint sm)
    {
    return pio_sm_get_tx_fifo_level (pio, sm);
    }

void stub_pio_sm_put_blocking (PIO pio, uint sm, uint32_t data)
    {
    pio_sm_put_blocking (pio, sm, data);
    }

uint32_t stub_pio_sm_get_blocking (PIO pio, uint sm)
    {
    return pio_sm_get_blocking (pio, sm);
    }

void stub_pio_sm_set_clkdiv_int_frac (PIO pio, uint sm, uint16_t div_int, uint8_t div_frac)
    {
    pio_sm_set_clkdiv_int_frac (pio, sm, div_int, div_frac);
    }

void stub_pio_sm_set_clkdiv (PIO pio, uint sm, float div)
    {
    pio_sm_set_clkdiv (pio, sm, div);
    }

void stub_pio_sm_clear_fifos (PIO pio, uint sm)
    {
    pio_sm_clear_fifos (pio, sm);
    }

#include "hardware/pio_instructions.h"

uint stub__pio_major_instr_bits (uint instr)
    {
    return _pio_major_instr_bits (instr);
    }

uint stub__pio_encode_instr_and_args (enum pio_instr_bits instr_bits, uint arg1, uint arg2)
    {
    return _pio_encode_instr_and_args (instr_bits, arg1, arg2);
    }

uint stub__pio_encode_instr_and_src_dest (enum pio_instr_bits instr_bits, enum pio_src_dest dest, uint value)
    {
    return _pio_encode_instr_and_src_dest (instr_bits, dest, value);
    }

uint stub_pio_encode_delay (uint cycles)
    {
    return pio_encode_delay (cycles);
    }

uint stub_pio_encode_sideset (uint sideset_bit_count, uint value)
    {
    return pio_encode_sideset (sideset_bit_count, value);
    }

uint stub_pio_encode_sideset_opt (uint sideset_bit_count, uint value)
    {
    return pio_encode_sideset_opt (sideset_bit_count, value);
    }

uint stub_pio_encode_jmp (uint addr)
    {
    return pio_encode_jmp (addr);
    }

uint stub_pio_encode_jmp_not_x (uint addr)
    {
    return pio_encode_jmp_not_x (addr);
    }

uint stub_pio_encode_jmp_x_dec (uint addr)
    {
    return pio_encode_jmp_x_dec (addr);
    }

uint stub_pio_encode_jmp_not_y (uint addr)
    {
    return pio_encode_jmp_not_y (addr);
    }

uint stub_pio_encode_jmp_y_dec (uint addr)
    {
    return pio_encode_jmp_y_dec (addr);
    }

uint stub_pio_encode_jmp_x_ne_y (uint addr)
    {
    return pio_encode_jmp_x_ne_y (addr);
    }

uint stub_pio_encode_jmp_pin (uint addr)
    {
    return pio_encode_jmp_pin (addr);
    }

uint stub_pio_encode_jmp_not_osre (uint addr)
    {
    return pio_encode_jmp_not_osre (addr);
    }

uint stub__pio_encode_irq (bool relative, uint irq)
    {
    return _pio_encode_irq (relative, irq);
    }

uint stub_pio_encode_wait_gpio (bool polarity, uint gpio)
    {
    return pio_encode_wait_gpio (polarity, gpio);
    }

uint stub_pio_encode_wait_pin (bool polarity, uint pin)
    {
    return pio_encode_wait_pin (polarity, pin);
    }

uint stub_pio_encode_wait_irq (bool polarity, bool relative, uint irq)
    {
    return pio_encode_wait_irq (polarity, relative, irq);
    }

uint stub_pio_encode_in (enum pio_src_dest src, uint count)
    {
    return pio_encode_in (src, count);
    }

uint stub_pio_encode_out (enum pio_src_dest dest, uint count)
    {
    return pio_encode_out (dest, count);
    }

uint stub_pio_encode_push (bool if_full, bool block)
    {
    return pio_encode_push (if_full, block);
    }

uint stub_pio_encode_pull (bool if_empty, bool block)
    {
    return pio_encode_pull (if_empty, block);
    }

uint stub_pio_encode_mov (enum pio_src_dest dest, enum pio_src_dest src)
    {
    return pio_encode_mov (dest, src);
    }

uint stub_pio_encode_mov_not (enum pio_src_dest dest, enum pio_src_dest src)
    {
    return pio_encode_mov_not (dest, src);
    }

uint stub_pio_encode_mov_reverse (enum pio_src_dest dest, enum pio_src_dest src)
    {
    return pio_encode_mov_reverse (dest, src);
    }

uint stub_pio_encode_irq_set (bool relative, uint irq)
    {
    return pio_encode_irq_set (relative, irq);
    }

uint stub_pio_encode_irq_wait (bool relative, uint irq)
    {
    return pio_encode_irq_wait (relative, irq);
    }

uint stub_pio_encode_irq_clear (bool relative, uint irq)
    {
    return pio_encode_irq_clear (relative, irq);
    }

uint stub_pio_encode_set (enum pio_src_dest dest, uint value)
    {
    return pio_encode_set (dest, value);
    }

uint stub_pio_encode_nop (void)
    {
    return pio_encode_nop ();
    }

#include "hardware/pwm.h"

void stub_check_slice_num_param (__unused uint slice_num)
    {
    check_slice_num_param (slice_num);
    }

uint stub_pwm_gpio_to_slice_num (uint gpio)
    {
    return pwm_gpio_to_slice_num (gpio);
    }

uint stub_pwm_gpio_to_channel (uint gpio)
    {
    return pwm_gpio_to_channel (gpio);
    }

void stub_pwm_config_set_phase_correct (pwm_config *c, bool phase_correct)
    {
    pwm_config_set_phase_correct (c, phase_correct);
    }

void stub_pwm_config_set_clkdiv (pwm_config *c, float div)
    {
    pwm_config_set_clkdiv (c, div);
    }

void stub_pwm_config_set_clkdiv_int_frac (pwm_config *c, uint8_t integer, uint8_t fract)
    {
    pwm_config_set_clkdiv_int_frac (c, integer, fract);
    }

void stub_pwm_config_set_clkdiv_int (pwm_config *c, uint div)
    {
    pwm_config_set_clkdiv_int (c, div);
    }

void stub_pwm_config_set_clkdiv_mode (pwm_config *c, enum pwm_clkdiv_mode mode)
    {
    pwm_config_set_clkdiv_mode (c, mode);
    }

void stub_pwm_config_set_output_polarity (pwm_config *c, bool a, bool b)
    {
    pwm_config_set_output_polarity (c, a, b);
    }

void stub_pwm_config_set_wrap (pwm_config *c, uint16_t wrap)
    {
    pwm_config_set_wrap (c, wrap);
    }

void stub_pwm_init (uint slice_num, pwm_config *c, bool start)
    {
    pwm_init (slice_num, c, start);
    }

pwm_config stub_pwm_get_default_config (void)
    {
    return pwm_get_default_config ();
    }

void stub_pwm_set_wrap (uint slice_num, uint16_t wrap)
    {
    pwm_set_wrap (slice_num, wrap);
    }

void stub_pwm_set_chan_level (uint slice_num, uint chan, uint16_t level)
    {
    pwm_set_chan_level (slice_num, chan, level);
    }

void stub_pwm_set_both_levels (uint slice_num, uint16_t level_a, uint16_t level_b)
    {
    pwm_set_both_levels (slice_num, level_a, level_b);
    }

void stub_pwm_set_gpio_level (uint gpio, uint16_t level)
    {
    pwm_set_gpio_level (gpio, level);
    }

uint16_t stub_pwm_get_counter (uint slice_num)
    {
    return pwm_get_counter (slice_num);
    }

void stub_pwm_set_counter (uint slice_num, uint16_t c)
    {
    pwm_set_counter (slice_num, c);
    }

void stub_pwm_advance_count (uint slice_num)
    {
    pwm_advance_count (slice_num);
    }

void stub_pwm_retard_count (uint slice_num)
    {
    pwm_retard_count (slice_num);
    }

void stub_pwm_set_clkdiv_int_frac (uint slice_num, uint8_t integer, uint8_t fract)
    {
    pwm_set_clkdiv_int_frac (slice_num, integer, fract);
    }

void stub_pwm_set_clkdiv (uint slice_num, float divider)
    {
    pwm_set_clkdiv (slice_num, divider);
    }

void stub_pwm_set_output_polarity (uint slice_num, bool a, bool b)
    {
    pwm_set_output_polarity (slice_num, a, b);
    }

void stub_pwm_set_clkdiv_mode (uint slice_num, enum pwm_clkdiv_mode mode)
    {
    pwm_set_clkdiv_mode (slice_num, mode);
    }

void stub_pwm_set_phase_correct (uint slice_num, bool phase_correct)
    {
    pwm_set_phase_correct (slice_num, phase_correct);
    }

void stub_pwm_set_enabled (uint slice_num, bool enabled)
    {
    pwm_set_enabled (slice_num, enabled);
    }

void stub_pwm_set_mask_enabled (uint32_t mask)
    {
    pwm_set_mask_enabled (mask);
    }

void stub_pwm_set_irq_enabled (uint slice_num, bool enabled)
    {
    pwm_set_irq_enabled (slice_num, enabled);
    }

void stub_pwm_set_irq_mask_enabled (uint32_t slice_mask, bool enabled)
    {
    pwm_set_irq_mask_enabled (slice_mask, enabled);
    }

void stub_pwm_clear_irq (uint slice_num)
    {
    pwm_clear_irq (slice_num);
    }

uint32_t stub_pwm_get_irq_status_mask (void)
    {
    return pwm_get_irq_status_mask ();
    }

void stub_pwm_force_irq (uint slice_num)
    {
    pwm_force_irq (slice_num);
    }

uint stub_pwm_get_dreq (uint slice_num)
    {
    return pwm_get_dreq (slice_num);
    }

#include "hardware/resets.h"

void stub_reset_block (uint32_t bits)
    {
    reset_block (bits);
    }

void stub_unreset_block (uint32_t bits)
    {
    unreset_block (bits);
    }

void stub_unreset_block_wait (uint32_t bits)
    {
    unreset_block_wait (bits);
    }

#include "hardware/spi.h"

uint stub_spi_get_index (const spi_inst_t *spi)
    {
    return spi_get_index (spi);
    }

spi_hw_t *stub_spi_get_hw (spi_inst_t *spi)
    {
    return spi_get_hw (spi);
    }

const spi_hw_t *stub_spi_get_const_hw (const spi_inst_t *spi)
    {
    return spi_get_const_hw (spi);
    }

void stub_spi_set_format (spi_inst_t *spi, uint data_bits, spi_cpol_t cpol, spi_cpha_t cpha, __unused spi_order_t order)
    {
    spi_set_format (spi, data_bits, cpol, cpha, order);
    }

void stub_spi_set_slave (spi_inst_t *spi, bool slave)
    {
    spi_set_slave (spi, slave);
    }

bool stub_spi_is_writable (const spi_inst_t *spi)
    {
    return spi_is_writable (spi);
    }

bool stub_spi_is_readable (const spi_inst_t *spi)
    {
    return spi_is_readable (spi);
    }

bool stub_spi_is_busy (const spi_inst_t *spi)
    {
    return spi_is_busy (spi);
    }

uint stub_spi_get_dreq (spi_inst_t *spi, bool is_tx)
    {
    return spi_get_dreq (spi, is_tx);
    }

#include "hardware/timer.h"

void stub_check_hardware_alarm_num_param (__unused uint alarm_num)
    {
    check_hardware_alarm_num_param (alarm_num);
    }

uint32_t stub_time_us_32 (void)
    {
    return time_us_32 ();
    }

bool stub_time_reached (absolute_time_t t)
    {
    return time_reached (t);
    }

#include "hardware/uart.h"

uint stub_uart_get_index (uart_inst_t *uart)
    {
    return uart_get_index (uart);
    }

uart_inst_t *stub_uart_get_instance (uint instance)
    {
    return uart_get_instance (instance);
    }

uart_hw_t *stub_uart_get_hw (uart_inst_t *uart)
    {
    return uart_get_hw (uart);
    }

void stub_uart_set_hw_flow (uart_inst_t *uart, bool cts, bool rts)
    {
    uart_set_hw_flow (uart, cts, rts);
    }

void stub_uart_set_format (uart_inst_t *uart, uint data_bits, uint stop_bits, uart_parity_t parity)
    {
    uart_set_format (uart, data_bits, stop_bits, parity);
    }

void stub_uart_set_irq_enables (uart_inst_t *uart, bool rx_has_data, bool tx_needs_data)
    {
    uart_set_irq_enables (uart, rx_has_data, tx_needs_data);
    }

bool stub_uart_is_enabled (uart_inst_t *uart)
    {
    return uart_is_enabled (uart);
    }

void stub_uart_set_fifo_enabled (uart_inst_t *uart, bool enabled)
    {
    uart_set_fifo_enabled (uart, enabled);
    }

bool stub_uart_is_writable (uart_inst_t *uart)
    {
    return uart_is_writable (uart);
    }

void stub_uart_tx_wait_blocking (uart_inst_t *uart)
    {
    uart_tx_wait_blocking (uart);
    }

bool stub_uart_is_readable (uart_inst_t *uart)
    {
    return uart_is_readable (uart);
    }

void stub_uart_write_blocking (uart_inst_t *uart, const uint8_t *src, size_t len)
    {
    uart_write_blocking (uart, src, len);
    }

void stub_uart_read_blocking (uart_inst_t *uart, uint8_t *dst, size_t len)
    {
    uart_read_blocking (uart, dst, len);
    }

void stub_uart_putc_raw (uart_inst_t *uart, char c)
    {
    uart_putc_raw (uart, c);
    }

void stub_uart_putc (uart_inst_t *uart, char c)
    {
    uart_putc (uart, c);
    }

void stub_uart_puts (uart_inst_t *uart, const char *s)
    {
    uart_puts (uart, s);
    }

char stub_uart_getc (uart_inst_t *uart)
    {
    return uart_getc (uart);
    }

void stub_uart_set_break (uart_inst_t *uart, bool en)
    {
    uart_set_break (uart, en);
    }

void stub_uart_default_tx_wait_blocking (void)
    {
    uart_default_tx_wait_blocking ();
    }

uint stub_uart_get_dreq (uart_inst_t *uart, bool is_tx)
    {
    return uart_get_dreq (uart, is_tx);
    }

#include "pico/multicore.h"

bool stub_multicore_fifo_rvalid (void)
    {
    return multicore_fifo_rvalid ();
    }

bool stub_multicore_fifo_wready (void)
    {
    return multicore_fifo_wready ();
    }

void stub_multicore_fifo_drain (void)
    {
    multicore_fifo_drain ();
    }

void stub_multicore_fifo_clear_irq (void)
    {
    multicore_fifo_clear_irq ();
    }

uint32_t stub_multicore_fifo_get_status (void)
    {
    return multicore_fifo_get_status ();
    }
